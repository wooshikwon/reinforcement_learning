# 📋 강의 문서 표준화 정책 (Lecture Document Standardization Policy)

## 목적
일관성 있고 전문적인 자료구조 및 알고리즘 강의 문서 작성

---

## 1. 🧹 텍스트 정리 규칙

### 1.1 Citation 태그 제거
**규칙:**
- 모든 `[cite_start]`, `[cite: n]`, `[cite: n, m]` 태그 완전 제거
- 태그 제거 후 문장 흐름이 자연스럽게 연결되도록 재구성
- 불필요한 중복 문장 통합

**Before:**
```markdown
[cite_start]트리는 그래프의 한 종류입니다[cite: 48, 51]. [cite_start]그래프는 정점들의 집합입니다[cite: 53].
```

**After:**
```markdown
트리는 그래프의 한 종류입니다. 그래프는 정점(vertices)들의 집합과 이들을 연결하는 간선(edges)들의 집합으로 이루어진 자료구조입니다.
```

### 1.2 제목 구조 정리
**규칙:**
- 제목에서 citation 태그 및 불필요한 마크다운 문법 제거
- `### [cite_start]## 슬라이드 N` → `### 슬라이드 N` 또는 의미있는 제목으로 변경
- 슬라이드 번호는 필요시 유지하거나 의미적 제목으로 대체

**Before:**
```markdown
### [cite_start]## 슬라이드 5: 트리의 정의 [cite: 47]
```

**After:**
```markdown
### 트리의 정의
```

### 1.3 수업 시작/종료 내용 제거
**규칙:**
- 수업 시작 부분의 인사말 및 오늘 수업 예고 내용 제거
- 수업 중간에 요약 및 다음 수업 예고 등 마무리 멘트 제거
- 강의 중간에 삽입된 시간 관련 멘트 제거 ("자, 이제~", "오늘은 여기까지~" 등)
- 학습 내용에 집중하고 불필요한 메타 정보 제거

**제거 대상 예시:**
```markdown
❌ "여러분 안녕하세요! 오늘은 강화학습의 기초에 대해 배워보겠습니다."
❌ "다음 시간에는 Policy Gradient에 대해 다루겠습니다."
❌ "자, 이제 본격적으로 시작해볼까요?"
❌ "오늘 수업은 여기까지입니다. 수고하셨습니다."
❌ "지난 시간에 배운 내용을 복습하면서 시작하겠습니다."
```

**유지 대상 예시:**
```markdown
✅ 강의 주제 및 학습 목표
✅ 핵심 개념 설명
✅ 알고리즘 및 구현
✅ 예제 및 실습
✅ 요약 섹션
```

---

## 2. 📐 수식 표현 규칙

### 2.1 인라인 수식
**규칙:**
- 텍스트 내의 짧은 수식: `$수식$` 형식 사용
- 변수, 복잡도, 간단한 공식 등에 적용

**예시:**
```markdown
- 시간 복잡도: $O(\log n)$
- 노드 개수: $n$개
- 팩토리얼: $n!$
- 정점 집합: $V$, 간선 집합: $E$
```

### 2.2 블록 수식
**규칙:**
- 독립적으로 강조해야 할 수식: `$$수식$$` 형식 사용
- 수식 위아래 빈 줄 추가로 가독성 확보

**예시:**
```markdown
트리의 높이는 다음과 같이 정의됩니다:

$$\text{height}(T) = \max(\text{depth}(v)) \text{ for all } v \in V$$

여기서 $V$는 정점의 집합입니다.
```

### 2.3 조건부 수식 (Cases)
**규칙:**
- 경우를 나누는 수식: `cases` 환경 사용
- 정렬 및 가독성 고려

**예시:**
```markdown
$$
f(n) = \begin{cases}
1 & \text{if } n=0 \\
n \times f(n-1) & \text{otherwise}
\end{cases}
$$
```

---

## 3. 💻 코드 블록 규칙

### 3.1 언어 명시
**규칙:**
- 모든 코드 블록에 언어 지정: ` ```언어 `
- 지원 언어: `c`, `cpp`, `python`, `java`, `pseudo` 등
- 의사코드는 `pseudo` 또는 가장 유사한 언어 사용

**Before:**
```
int factorial(int n) {
    return n * factorial(n-1);
}
```

**After:**
```cpp
int factorial(int n) {
    if (n == 0) return 1;
    return n * factorial(n-1);
}
```

### 3.2 코드 주석
**규칙:**
- 함수 시작 부분에 간단한 설명 주석 추가
- 핵심 로직에 인라인 주석으로 설명
- 베이스 케이스, 재귀 케이스 등 명시

**예시:**
```cpp
// 이진 탐색: 정렬된 배열에서 target 찾기
bool binarySearch(const int data[], int target, int low, int high) {
    if (low > high)              // 베이스 케이스: 탐색 실패
        return false;

    int mid = (low + high) / 2;
    if (target == data[mid])     // 베이스 케이스: 탐색 성공
        return true;
    else if (target < data[mid])
        return binarySearch(data, target, low, mid - 1);  // 왼쪽 탐색
    else
        return binarySearch(data, target, mid + 1, high); // 오른쪽 탐색
}
```

### 3.3 코드 설명 섹션
**규칙:**
- 코드 블록 다음에 `**코드 설명:**` 섹션 추가
- 주요 부분을 항목별로 설명
- 파라미터, 반환값, 로직 설명 포함

**예시:**
```markdown
**코드 설명:**
- `if (low > high)`: 탐색 범위가 없을 때 false 반환 (탐색 실패)
- `int mid = (low + high) / 2`: 중간 인덱스 계산
- 재귀 케이스: 조건에 따라 왼쪽 또는 오른쪽 절반 탐색
```

---

## 4. 📚 문서 구조 규칙

### 4.1 목차 (Table of Contents)
**규칙:**
- 모든 강의 문서 시작 부분에 목차 추가
- 주요 섹션을 2-3 단계 깊이로 구성
- 앵커 링크로 빠른 이동 지원

**템플릿:**
```markdown
# Lecture XX: 제목

## 목차
- [핵심 개념](#핵심-개념)
  - [개념 1](#개념-1)
  - [개념 2](#개념-2)
- [알고리즘](#알고리즘)
  - [알고리즘 1](#알고리즘-1)
  - [알고리즘 2](#알고리즘-2)
- [요약](#요약)
```

### 4.2 섹션 구분
**규칙:**
- 주요 섹션 사이에 `---` 구분선 사용
- 일관된 제목 계층 구조 유지 (`#` → `##` → `###` → `####`)
- 하위 섹션은 최대 4단계까지만 사용

**구조:**
```markdown
# Lecture Title (H1 - 문서당 1개)

## 목차 (H2)

## 강의 소개 (H2)

---

## 주요 섹션 1 (H2)

### 하위 개념 1 (H3)

#### 세부 설명 (H4)

---

## 주요 섹션 2 (H2)

---

## 요약 (H2)
```

### 4.3 설명 강화 패턴
**규칙:**
- 각 알고리즘/개념에 대해 다음 구조 사용:
  1. **개념 설명**: 무엇인지
  2. **필요성/동기**: 왜 배우는지
  3. **구현**: 어떻게 구현하는지 (코드)
  4. **코드 설명**: 코드의 각 부분 설명
  5. **예제 추적**: 실행 과정 시각화
  6. **복잡도 분석**: 시간/공간 복잡도

**템플릿:**
```markdown
### 알고리즘명

#### 개념 설명
[알고리즘이 무엇인지 설명]

#### 필요성
[왜 이 알고리즘이 필요한지]

#### 구현
```언어
[코드]
```

**코드 설명:**
- [주요 부분 설명]

#### 예제 추적
[단계별 실행 과정]

#### 복잡도 분석
- 시간 복잡도: $O(?)$
- 공간 복잡도: $O(?)$
```

### 4.4 시각적 요소
**규칙:**
- 코드 블록, 수식, 예제는 박스/구분으로 시각적 강조
- 중요한 개념은 **볼드**, 강조할 용어는 *이탤릭* 또는 `코드 스타일`
- 항목화(bullet, numbering) 적극 활용

**예시:**
```markdown
**핵심 원칙:**
1. 베이스 케이스가 반드시 존재해야 함
2. 재귀 호출 시 문제 크기가 줄어들어야 함
3. 재귀 케이스가 올바르게 동작해야 함

> **💡 핵심 포인트**
> 트리의 높이가 $h$일 때, 최악의 경우 $O(h)$의 시간이 소요됩니다.
```

---

## 5. 📝 일관성 규칙

### 5.1 용어 통일
**규칙:**
- 한글/영문 용어 일관성 유지
- 처음 소개 시: **한글 (English)** 형식
- 이후 사용 시: 한글 또는 영문 중 하나로 통일

**예시:**
```markdown
**노드 (Node)**: 트리의 기본 구성 요소
**간선 (Edge)**: 노드를 연결하는 선

이후 사용:
- 각 노드는 0개 이상의 자식을 가질 수 있습니다.
- 간선은 부모-자식 관계를 나타냅니다.
```

### 5.2 주요 용어 리스트
**표준 용어:**
- 노드 (Node), 정점 (Vertex)
- 간선 (Edge)
- 루트 (Root)
- 잎 노드 (Leaf Node), 외부 노드 (External Node)
- 내부 노드 (Internal Node)
- 부모 (Parent), 자식 (Child), 형제 (Sibling)
- 조상 (Ancestor), 자손 (Descendant)
- 서브트리 (Subtree)
- 깊이 (Depth), 높이 (Height)
- 경로 (Path), 경로의 길이 (Length of Path)

---

## 6. 🎯 품질 체크리스트

### 문서 완성 전 확인사항

#### ✅ 내용 완성도
- [ ] 모든 citation 태그 제거됨
- [ ] 문장이 자연스럽게 연결됨
- [ ] 중복 문장 제거됨

#### ✅ 수식 표현
- [ ] 모든 수식이 `$` 또는 `$$`로 표현됨
- [ ] 복잡도 표기 일관성 (`$O(\log n)$`)
- [ ] 수식 위아래 적절한 공백

#### ✅ 코드 품질
- [ ] 모든 코드 블록에 언어 명시
- [ ] 주석이 적절히 추가됨
- [ ] 코드 설명 섹션 존재

#### ✅ 구조
- [ ] 목차 존재
- [ ] 제목 계층 구조 올바름
- [ ] 섹션 구분선 적절히 사용
- [ ] 요약 섹션 존재

#### ✅ 일관성
- [ ] 용어가 통일됨
- [ ] 강조 스타일 일관됨
- [ ] 들여쓰기 일관됨

---

## 7. 🔄 작업 프로세스

### 단계별 문서 개선 절차

**Step 1: 사전 분석**
```bash
1. 파일 크기 확인 (너무 크면 부분 처리)
2. Citation 태그 개수 파악
3. 수식 및 코드 블록 개수 확인
```

**Step 2: 자동 정리**
```bash
1. Citation 태그 제거
2. 제목 구조 정리
3. 중복 문장 통합
```

**Step 3: 수식 및 코드 개선**
```bash
1. 인라인 수식 변환
2. 블록 수식 포맷팅
3. 코드 블록 언어 명시
4. 주석 및 설명 추가
```

**Step 4: 구조 개선**
```bash
1. 목차 생성
2. 섹션 구분선 추가
3. 설명 섹션 추가 (코드 설명, 예제 등)
4. 요약 섹션 작성
```

**Step 5: 최종 검토**
```bash
1. 체크리스트 확인
2. 전체 가독성 검토
3. 링크 및 앵커 테스트
```

---

## 8. 📄 문서 템플릿

### 강의 문서 표준 템플릿

```markdown
# Lecture XX: [강의 제목]

## 목차
- [주요 개념](#주요-개념)
- [알고리즘](#알고리즘)
- [예제](#예제)
- [요약](#요약)

---

## 강의 소개

[강의 개요 및 학습 목표]

---

## 주요 개념

### 개념 1

#### 정의
[개념 설명]

#### 특징
- 특징 1
- 특징 2

#### 예시
[실제 사례]

---

## 알고리즘

### 알고리즘명

#### 개념 설명
[알고리즘 소개]

#### 구현

```언어
[코드]
```

**코드 설명:**
- [설명]

#### 예제 추적
[단계별 실행]

#### 복잡도 분석
- 시간 복잡도: $O(?)$
- 공간 복잡도: $O(?)$

---

## 요약

### 학습 내용 정리

1. **핵심 개념**:
   - 개념 1
   - 개념 2

2. **주요 알고리즘**:
   - 알고리즘 1: $O(?)$
   - 알고리즘 2: $O(?)$

3. **중요 포인트**:
   - 포인트 1
   - 포인트 2
```

---

## 9. 🚀 적용 예시

### Before (개선 전)
```markdown
### [cite_start]## 슬라이드 5: 트리의 정의 [cite: 47]

[cite_start]트리는 그래프입니다[cite: 48]. [cite_start]n개 노드는 n-1개 간선[cite: 90].

int factorial(int n) {
    return n * factorial(n-1);
}
```

### After (개선 후)
```markdown
### 트리의 정의

트리는 그래프의 한 종류로, 사이클이 없는 연결 그래프입니다.
$n$개의 노드를 가진 트리는 항상 $n-1$개의 간선을 가집니다.

#### 구현

```cpp
// 팩토리얼 계산: n! = n × (n-1) × ... × 1
int factorial(int n) {
    if (n == 0) return 1;        // 베이스 케이스
    return n * factorial(n - 1); // 재귀 케이스
}
```

**코드 설명:**
- `if (n == 0)`: 베이스 케이스로 재귀 종료 조건
- `n * factorial(n-1)`: 재귀 케이스로 문제를 더 작게 분할
```

---

## 10. 📌 참고사항

### 주의사항
1. **파일 크기**: 25,000 토큰 초과 시 부분 읽기 필요
2. **백업**: 원본 파일 수정 전 백업 권장
3. **점진적 개선**: 한 번에 모든 것을 바꾸기보다 단계적 개선
4. **일관성 우선**: 새로운 스타일보다 기존 문서와의 일관성 유지

### 도구 활용
- **Citation 태그 제거**: 정규표현식 활용
- **수식 변환**: 자동화 스크립트 고려
- **코드 포맷팅**: 언어별 포맷터 사용
- **링크 검증**: Markdown linter 활용

---

**버전**: 1.0
**작성일**: 2025
**적용 범위**: 모든 자료구조 및 알고리즘 강의 문서
